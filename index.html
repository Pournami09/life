<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poro's Life</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=edit" />
    <style>
        @import url('https://unpkg.com/geist@latest/dist/font.css');
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: white;
            color: #000;
            font-size: 16px;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        .layout {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 359px;
            min-width: 250px;
            max-width: 600px;
            height: 100vh;
            padding: 2rem;
            overflow-y: auto;
            background: white;
            border-right: 1px solid #e0e0e0;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-content {
            flex: 1;
        }
        
        .profile-image-container {
            position: relative;
            display: inline-block;
            margin-bottom: 1.5rem;
        }
        
        .profile-image {
            width: 96px;
            height: 96px;
            border-radius: 48px;
            object-fit: cover;
            display: block;
            background: #F5F5F5;
        }
        
        .edit-image-btn {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #F5F5F5;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
        }
        
        .edit-image-btn:hover {
            background: #FF6B35;
            transform: scale(1.1);
        }
        
        .edit-image-btn:hover .material-symbols-outlined {
            color: white;
        }
        
        .edit-image-btn .material-symbols-outlined {
            font-size: 14px;
            color: #474747;
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 20;
        }
        
        .crop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .crop-modal.show {
            display: flex;
        }
        
        .crop-modal-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Modal States */
        .modal-state {
            display: none;
        }
        
        .modal-state.active {
            display: block;
        }
        
        /* EMPTY State */
        .upload-area {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #fafafa;
        }
        
        .upload-area:hover {
            border-color: #FF6B35;
            background: #fff5f2;
        }
        
        .upload-area.dragover {
            border-color: #FF6B35;
            background: #fff5f2;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 1rem;
            color: #727272;
        }
        
        .upload-text {
            font-size: 16px;
            color: #474747;
            margin-bottom: 0.5rem;
        }
        
        .upload-hint {
            font-size: 14px;
            color: #727272;
            margin-top: 0.5rem;
        }
        
        /* CROPPING State */
        .crop-stage {
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            margin: 1rem auto;
            position: relative;
            overflow: hidden;
            background: #000;
            border-radius: 8px;
        }
        
        .crop-preview-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        .crop-preview-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .crop-overlay-top,
        .crop-overlay-bottom,
        .crop-overlay-left,
        .crop-overlay-right {
            position: absolute;
            background: rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .crop-overlay-top {
            top: 0;
            left: 0;
            right: 0;
        }
        
        .crop-overlay-bottom {
            bottom: 0;
            left: 0;
            right: 0;
        }
        
        .crop-overlay-left {
            top: 0;
            bottom: 0;
            left: 0;
        }
        
        .crop-overlay-right {
            top: 0;
            bottom: 0;
            right: 0;
        }
        
        .crop-box {
            position: absolute;
            border: 2px solid #FF6B35;
            box-sizing: border-box;
            cursor: move;
            background: transparent;
            pointer-events: auto;
            z-index: 20;
        }
        
        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #FF6B35;
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            z-index: 30;
            pointer-events: auto;
        }
        
        .crop-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nwse-resize;
        }
        
        .crop-handle.ne {
            top: -6px;
            right: -6px;
            cursor: nesw-resize;
        }
        
        .crop-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: nesw-resize;
        }
        
        .crop-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: nwse-resize;
        }
        
        .crop-controls {
            display: flex;
            gap: 1rem;
            margin-top: auto;
            padding-top: 1.5rem;
            justify-content: flex-end;
            flex-shrink: 0;
        }
        
        .crop-controls.left {
            justify-content: flex-start;
        }
        
        .crop-controls.center {
            justify-content: space-between;
        }
        
        .crop-modal-header {
            flex-shrink: 0;
        }
        
        .crop-modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        /* SAVING State */
        .saving-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .file-input-hidden {
            display: none;
        }
        
        .crop-controls button {
            padding: 8px 16px;
        }
        
        .file-input-wrapper {
            margin-bottom: 1rem;
        }
        
        .file-input-wrapper input[type="file"] {
            width: 100%;
            padding: 8px;
        }
        
        .resizer {
            position: fixed;
            left: 359px;
            top: 0;
            width: 1px;
            height: 100vh;
            background: #e0e0e0;
            cursor: col-resize;
            z-index: 101;
            user-select: none;
            transition: background 0.15s ease;
        }
        
        .resizer:hover {
            background: #FF6B35;
        }
        
        .resizer.dragging {
            background: #FF6B35;
        }
        
        .main-content {
            margin-left: 359px;
            padding-top: 2rem;
            padding-right: 6rem;
            padding-bottom: 2rem;
            padding-left: 6rem;
            width: calc(100% - 359px);
            overflow-y: auto;
            height: 100vh;
            position: relative;
        }
        
        .main-content::before {
            content: '';
            position: fixed;
            top: 0;
            left: 359px;
            right: 0;
            height: 80px;
            background: linear-gradient(to bottom, white, rgba(255, 255, 255, 0));
            pointer-events: none;
            z-index: 50;
        }
        
        .main-content::after {
            content: '';
            position: fixed;
            bottom: 0;
            left: 359px;
            right: 0;
            height: 80px;
            background: linear-gradient(to top, white, rgba(255, 255, 255, 0));
            pointer-events: none;
            z-index: 50;
        }
        
        .footer {
            width: 100%;
            margin-top: 2rem;
            padding-top: 2rem;
            padding-bottom: 0;
            text-align: left;
            font-size: 0.875rem;
            color: #727272;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            flex-direction: column;
            gap: 16px;
        }
        
        .footer a {
            color: #9E9E9E;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            transition: opacity 0.2s ease;
        }
        
        .footer a:hover {
            opacity: 0.7;
        }
        
        .footer a svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        .footer a img {
            filter: grayscale(100%) brightness(0.6);
            opacity: 0.7;
        }

        .container {
            max-width: 100%;
        }

        h1 {
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .decade-header {
            font-size: 16px;
            margin: 2rem 0 1rem 0;
            padding-top: 4rem;
            font-weight: 500;
            clear: both;
        }
        
        .decade-header:first-of-type {
            padding-top: 0;
        }

        .year-box {
            border: 1px solid #E5E5E5;
            float: left;
            height: 2em;
            padding: 2px 5px;
            margin: 2px;
            font-size: 16px;
            line-height: 1.5;
            white-space: nowrap;
            text-align: center;
            background-color: #E5E5E5;
            color: #474747;
        }

        .week-box {
            border: 1px solid #e0e0e0;
            float: left;
            height: 2em;
            padding: 2px 5px;
            margin: 2px;
            font-size: 16px;
            line-height: 1.5;
            text-align: left;
            position: relative;
            cursor: pointer;
            display: inline-block;
            vertical-align: top;
            color: #727272;
        }

        .week-box:hover {
            background-color: #f5f5f5;
            z-index: 10;
        }

        .week-box.has-event {
            background-color: transparent;
            border-color: #e0e0e0;
            color: #727272;
            white-space: normal;
            overflow: visible;
            height: auto;
            min-height: 2em;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .week-box.has-event:hover {
            background-color: #f5f5f5;
            z-index: 10;
        }

        .week-box.future {
            background-color: #fafafa;
            border-color: #e0e0e0;
            opacity: 0.5;
        }

        .week-box.today {
            background: #FF6B35 !important;
            border-color: #FF6B35 !important;
            color: white !important;
            font-weight: 500;
        }

        .week-box.today.has-event {
            color: white !important;
        }

        .event-tooltip {
            position: fixed;
            background: white;
            color: #000;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            max-width: 350px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            border: 1px solid #D0D0D0;
        }
        
        .event-tooltip-images {
            margin-top: 8px;
            display: flex;
            flex-direction: row;
            gap: 8px;
        }
        
        .event-tooltip-image {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #D0D0D0;
            display: block;
        }
        
        .event-tooltip a {
            pointer-events: auto;
            cursor: pointer;
            color: #FF6B35;
            text-decoration: underline;
        }
        
        .event-tooltip a:hover {
            text-decoration: underline;
            opacity: 0.8;
        }

        .event-tooltip.show {
            display: block;
        }

        .event-name {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .event-desc {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 4px;
        }

        .event-date {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .category-chip {
            display: inline-block;
            padding: 4px 12px;
            margin: 2px;
            margin-top: 8px;
            background: #E5E5E5;
            color: #474747;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        a {
            color: #FF6B35;
            text-decoration: underline;
        }

        a:hover {
            text-decoration: underline;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            font-size: 16px;
        }

        .clearfix::after {
            content: "";
            display: table;
            clear: both;
        }

        .controls {
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .controls button,
        .controls a {
            width: 100%;
        }
        
        .controls a button {
            width: 100%;
        }

        button {
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 16px;
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            color: #000;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #f5f5f5;
        }

        .form-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            display: none;
        }

        .form-section.show {
            display: block;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-size: 16px;
            font-weight: 500;
        }

        input, textarea, select {
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 16px;
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .events-list {
            margin-top: 2rem;
        }

        .event-item {
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #fafafa;
        }

        .event-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .event-date-display {
            font-weight: 500;
            font-size: 16px;
        }

        .event-actions {
            display: flex;
            gap: 0.5rem;
        }

        .event-name-display {
            font-size: 16px;
            margin-bottom: 0.25rem;
        }

        .event-details {
            font-size: 14px;
            color: #666;
            margin-top: 0.5rem;
        }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: #e3f2fd;
            border-radius: 12px;
            font-size: 12px;
        }

        .intro-text {
            font-size: 14px;
            line-height: 1.6;
            color: #727272;
            margin-top: 1rem;
            margin-bottom: 3rem;
        }

        .intro-text a {
            color: #474747;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="layout">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <div class="profile-image-container">
                    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='96' height='96'%3E%3Crect width='96' height='96' fill='%23F5F5F5'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='14' fill='%23727272'%3EPoro%3C/text%3E%3C/svg%3E" alt="Poro" class="profile-image" id="profile-image" onerror="this.style.backgroundColor='#F5F5F5'; this.style.display='block';">
                    <button class="edit-image-btn" id="edit-image-btn" title="Edit profile image">
                        <span class="material-symbols-outlined">edit</span>
                    </button>
                </div>
                <h1>Hi, I'm Poro. This is my life so far.</h1>
                
                <div class="intro-text">
                    I found this gem while stalking portfolios (a professional habit). It's a simple view of my life in weeks, because zooming out makes patterns easier to see.<br><br>
                    Inspired by <a href="https://busterbenson.com/life-in-weeks" target="_blank">Buster Benson</a> and <a href="https://www.samstephenson.com/life-overview/" target="_blank">Sam Stephenson</a>, and most heavily by <a href="https://waitbutwhy.com/2014/05/life-weeks.html" target="_blank">Tim Urban's Wait But Why</a>.
                </div>
            </div>
            
            <div class="controls">
                <a href="events.html" style="text-decoration: none;">
                    <button>Manage Events</button>
                </a>
                <button id="reload-btn">Reload Visualization</button>
                <button id="clear-storage-btn">Clear Cache & Reload</button>
            </div>
            
            <footer class="footer">
                <div>thanks for reading! say hi</div>
                <div style="display: flex; gap: 16px; font-size: 0.875rem; align-items: center;">
                    <a href="https://www.linkedin.com/in/pournamipottekat/" target="_blank" title="LinkedIn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                        </svg>
                    </a>
                    <a href="https://x.com/Poro090" target="_blank" title="X">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                        </svg>
                    </a>
                    <a href="https://pournamipottekat09.substack.com/" target="_blank" title="Substack">
                        <img src="https://substackcdn.com/image/fetch/$s_!xBQa!,w_500,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack.com%2Fimg%2Fsubstack.png" alt="Substack" width="28" height="28" style="display: block;">
                    </a>
                </div>
                <div style="font-size: 0.875rem; color: #727272;">vibe coded with cursor, deployed on vercel</div>
            </footer>
        </div>
        
        <div class="resizer" id="resizer"></div>
        
        <div class="main-content" id="main-content">
            <div class="container">
                <div id="loading" class="loading">Loading your life in weeks...</div>
                <div id="life-visualization"></div>
            </div>
        </div>
    </div>

    <div id="tooltip" class="event-tooltip"></div>
    
    <!-- Crop Modal -->
    <div class="crop-modal" id="crop-modal" role="dialog" aria-labelledby="modal-title" aria-modal="true">
        <div class="crop-modal-content">
            <div class="crop-modal-header">
                <h2 id="modal-title" style="margin-bottom: 1rem; font-size: 20px;">Edit Profile Image</h2>
            </div>
            
            <!-- EMPTY State -->
            <div class="modal-state active" id="modal-empty">
                <div class="crop-modal-body">
                    <div class="upload-area" id="upload-area">
                        <div class="upload-icon">ðŸ“·</div>
                        <div class="upload-text">Click to upload or drag and drop</div>
                        <div class="upload-hint">Supports JPG, PNG, WEBP (max 10MB)</div>
                    </div>
                    <input type="file" id="image-input" accept="image/jpeg,image/png,image/webp" class="file-input-hidden">
                </div>
                <div class="crop-controls">
                    <button id="cancel-empty-btn">Cancel</button>
                </div>
            </div>
            
            <!-- CROPPING State -->
            <div class="modal-state" id="modal-cropping">
                <div class="crop-modal-body">
                    <div class="crop-stage" id="crop-stage">
                        <div class="crop-preview-container" id="crop-preview-container">
                            <img id="crop-preview" style="display: none;">
                            <div class="crop-overlay" id="crop-overlay"></div>
                        </div>
                    </div>
                </div>
                <div class="crop-controls center">
                    <button id="replace-image-btn">Replace</button>
                    <div>
                        <button id="cancel-crop-btn">Cancel</button>
                        <button id="save-crop-btn" style="background: #FF6B35; color: white; border-color: #FF6B35; margin-left: 0.5rem;">Save</button>
                    </div>
                </div>
            </div>
            
            <!-- SAVING State -->
            <div class="modal-state" id="modal-saving">
                <div class="crop-modal-body" style="text-align: center; padding: 3rem;">
                    <div class="saving-spinner"></div>
                    <div style="margin-top: 1rem; color: #727272;">Saving...</div>
                </div>
            </div>
            
            <canvas id="crop-canvas" style="display: none;"></canvas>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script>
        // Configuration - update these to match your data
        const START_DATE = '2001-03-09'; // Your birth date (update this in the YAML file)
        const END_YEAR = 2101; // Expected end year (100 years from start date)

        let eventsData = {};
        let actualStartDate = START_DATE;

        // Load from localStorage if available, otherwise from YAML
        function loadFromStorage() {
            const stored = localStorage.getItem('lifeEvents');
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Error parsing stored data:', e);
                }
            }
            return null;
        }

        function saveToStorage() {
            localStorage.setItem('lifeEvents', JSON.stringify(eventsData));
        }

        // Load and parse YAML file
        async function loadData() {
            try {
                // Try to load from localStorage first
                const storedData = loadFromStorage();
                if (storedData) {
                    eventsData = storedData;
                    updateStartDate();
                    renderVisualization();
                    return;
                }

                // Otherwise load from YAML file
                const response = await fetch('life-in-weeks.yml');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const yamlText = await response.text();
                
                if (!yamlText || yamlText.trim().length === 0) {
                    throw new Error('YAML file is empty');
                }
                
                eventsData = jsyaml.load(yamlText);
                
                if (!eventsData || Object.keys(eventsData).length === 0) {
                    throw new Error('YAML file parsed but contains no data');
                }
                
                // Normalize event data keys (remove quotes)
                const normalizedData = {};
                Object.keys(eventsData).forEach(key => {
                    const normalizedKey = key.replace(/^'|'$/g, '');
                    normalizedData[normalizedKey] = eventsData[key];
                });
                eventsData = normalizedData;
                
                updateStartDate();
                console.log('Loaded events:', Object.keys(eventsData).length, 'dates');
                console.log('Start date:', actualStartDate);
                console.log('Sample events:', Object.keys(eventsData).slice(0, 5));
                saveToStorage();
                renderVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
                const errorMsg = error.message || 'Unknown error';
                document.getElementById('loading').innerHTML = `Error loading data: ${errorMsg}<br><br>Make sure you're accessing the page via http://localhost:8000 (not file://)`;
            }
        }

        function updateStartDate() {
            const dates = Object.keys(eventsData).filter(date => date.match(/^\d{4}-\d{2}-\d{2}$/));
            if (dates.length > 0) {
                dates.sort();
                actualStartDate = dates[0];
            }
        }

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' });
        }

        function formatDateForTooltip(dateStr) {
            // Parse YYYY-MM-DD directly to avoid timezone issues
            if (!dateStr) return '';
            const parts = dateStr.split('-');
            if (parts.length === 3) {
                const year = parts[0];
                const monthNum = parseInt(parts[1], 10);
                const day = parseInt(parts[2], 10);
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${monthNames[monthNum - 1]} ${day}, ${year}`;
            }
            // Fallback to Date parsing if format is unexpected
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        }

        function getWeeksInYear(year, startDate) {
            const start = new Date(`${year}-${startDate.split('-')[1]}-${startDate.split('-')[2]}`);
            const end = new Date(`${year + 1}-${startDate.split('-')[1]}-${startDate.split('-')[2]}`);
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return Math.ceil(diffDays / 7);
        }

        function getWeekDate(year, week, startDate) {
            const start = new Date(`${year}-${startDate.split('-')[1]}-${startDate.split('-')[2]}`);
            const weekMs = week * 7 * 24 * 60 * 60 * 1000;
            return new Date(start.getTime() + weekMs);
        }

        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function getEventsForWeek(year, week, startDate) {
            const weekStart = getWeekDate(year, week, startDate);
            const events = [];
            
            for (let day = 0; day < 7; day++) {
                const date = new Date(weekStart);
                date.setDate(date.getDate() + day);
                const dateKey = formatDateKey(date);
                
                // Check exact match first
                if (eventsData[dateKey]) {
                    events.push(...eventsData[dateKey].map(event => ({
                        ...event,
                        date: dateKey
                    })));
                }
            }
            
            return events;
        }

        function showTooltip(event, element) {
            const tooltip = document.getElementById('tooltip');
            const rect = element.getBoundingClientRect();
            
            // Get the date from the event first (if it has a specific date), otherwise use the week start date
            const dateKey = (event && event.date) ? event.date : element.getAttribute('data-date');
            const formattedDate = formatDateForTooltip(dateKey);
            
            let content = `<div class="event-date" style="font-weight: 600; margin-bottom: 6px; font-size: 14px;">${formattedDate}</div>`;
            
            if (event && event.name) {
                content += `<div class="event-name">${event.name}</div>`;
                if (event.desc) {
                    content += `<div class="event-desc">${event.desc}</div>`;
                }
                if (event.images && event.images.length > 0) {
                    content += `<div class="event-tooltip-images">`;
                    event.images.slice(0, 3).forEach(imageUrl => {
                        content += `<img src="${imageUrl}" alt="Event image" class="event-tooltip-image" onerror="this.style.display='none'">`;
                    });
                    content += `</div>`;
                }
                if (event.link) {
                    content += `<div class="event-desc" style="margin-top: 4px;"><a href="${event.link}" target="_blank" style="color: #FF6B35;">${event.link}</a></div>`;
                }
                if (event.category) {
                    content += `<div style="margin-top: 4px;"><span class="category-chip">${event.category}</span></div>`;
                }
            } else {
                content += `<div class="event-desc" style="opacity: 0.7;">No events</div>`;
            }
            
            tooltip.innerHTML = content;
            tooltip.classList.add('show');
            
            // Position tooltip 8px above the week box using fixed positioning
            // getBoundingClientRect() gives viewport-relative coordinates which work with fixed positioning
            setTimeout(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                // Center the tooltip horizontally above the box
                const tooltipLeft = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
                // Position 8px above the box (using viewport coordinates)
                const tooltipTop = rect.top - tooltipRect.height - 8;
                
                tooltip.style.left = tooltipLeft + 'px';
                tooltip.style.top = tooltipTop + 'px';
                
                // Adjust if tooltip goes off screen
                const adjustedRect = tooltip.getBoundingClientRect();
                if (adjustedRect.left < 8) {
                    tooltip.style.left = '8px';
                }
                if (adjustedRect.right > window.innerWidth - 8) {
                    tooltip.style.left = (window.innerWidth - adjustedRect.width - 8) + 'px';
                }
                if (adjustedRect.top < 8) {
                    // If tooltip goes above viewport, show it below instead
                    tooltip.style.top = (rect.bottom + 8) + 'px';
                }
            }, 0);
        }

        let hideTooltipTimeout = null;
        
        function hideTooltip() {
            // Add a small delay before hiding to allow moving to tooltip
            hideTooltipTimeout = setTimeout(() => {
                const tooltip = document.getElementById('tooltip');
                tooltip.classList.remove('show');
            }, 100);
        }
        
        function cancelHideTooltip() {
            if (hideTooltipTimeout) {
                clearTimeout(hideTooltipTimeout);
                hideTooltipTimeout = null;
            }
        }

        function renderVisualization() {
            document.getElementById('loading').style.display = 'none';
            const container = document.getElementById('life-visualization');
            container.innerHTML = '';

            const startYear = parseInt(actualStartDate.split('-')[0]);
            const today = new Date();
            
            console.log('Rendering visualization from', startYear, 'to', END_YEAR);
            console.log('Total events in data:', Object.keys(eventsData).length);
            
            for (let year = startYear; year <= END_YEAR; year++) {
                const age = year - startYear;
                const ageModulo = age % 10;
                
                // Add decade header
                if (ageModulo === 0) {
                    const decadeDiv = document.createElement('div');
                    decadeDiv.className = 'decade-header clearfix';
                    
                    let decadeText = '';
                    if (age === 0) {
                        decadeText = 'My first ten years';
                    } else if (age === 10) {
                        decadeText = 'My teens';
                    } else if (age === 100) {
                        decadeText = 'Endgame';
                    } else {
                        decadeText = `My ${age}s`;
                    }
                    
                    decadeDiv.textContent = decadeText;
                    container.appendChild(decadeDiv);
                }
                
                // Add year box
                const yearDiv = document.createElement('div');
                yearDiv.className = 'year-box';
                // At the beginning of each decade, show "X in YYYY", otherwise show "X yrs old"
                if (ageModulo === 0) {
                    yearDiv.textContent = `${age} in ${year}`;
                } else {
                    yearDiv.textContent = `${age} yrs old`;
                }
                container.appendChild(yearDiv);
                
                // Add week boxes
                const weeksInYear = getWeeksInYear(year, actualStartDate);
                let eventCount = 0;
                for (let week = 0; week < weeksInYear; week++) {
                    const weekDate = getWeekDate(year, week, actualStartDate);
                    const weekEnd = new Date(weekDate);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                    const isFuture = weekDate > today;
                    // Check if today falls within this week
                    const isToday = today >= weekDate && today <= weekEnd;
                    const events = getEventsForWeek(year, week, actualStartDate);
                    const hasEvent = events.length > 0;
                    
                    if (hasEvent) {
                        eventCount += events.length;
                    }
                    
                    const weekDiv = document.createElement('div');
                    weekDiv.className = 'week-box';
                    if (hasEvent) {
                        weekDiv.classList.add('has-event');
                        // Display event names directly in the box text
                        weekDiv.textContent = events.map(e => e.name).join(' ');
                    }
                    if (isToday) {
                        weekDiv.classList.add('today');
                        // Add "Today" label if there are no events, or prepend it if there are events
                        if (hasEvent) {
                            weekDiv.textContent = 'Today â€¢ ' + events.map(e => e.name).join(' ');
                        } else {
                            weekDiv.textContent = 'Today';
                        }
                    }
                    if (isFuture) {
                        weekDiv.classList.add('future');
                    }
                    
                    weekDiv.setAttribute('data-date', formatDateKey(weekDate));
                    
                    // Add tooltip for ALL week boxes
                    let scrollHandler = null;
                    weekDiv.addEventListener('mouseenter', (e) => {
                        // Prevent duplicate tooltips
                        e.stopPropagation();
                        cancelHideTooltip();
                        // Show tooltip with event details if available, otherwise show date only
                        const showTooltipHandler = () => {
                            if (hasEvent && events.length > 0) {
                                showTooltip(events[0], weekDiv);
                            } else {
                                showTooltip(null, weekDiv);
                            }
                        };
                        showTooltipHandler();
                        // Update tooltip position on scroll
                        scrollHandler = () => {
                            if (weekDiv.matches(':hover') || document.getElementById('tooltip').classList.contains('show')) {
                                if (hasEvent && events.length > 0) {
                                    showTooltip(events[0], weekDiv);
                                } else {
                                    showTooltip(null, weekDiv);
                                }
                            }
                        };
                        window.addEventListener('scroll', scrollHandler);
                    });
                    
                    weekDiv.addEventListener('mouseleave', (e) => {
                        // Add a small delay to allow moving to tooltip
                        hideTooltip();
                        if (scrollHandler) {
                            window.removeEventListener('scroll', scrollHandler);
                            scrollHandler = null;
                        }
                    });
                    
                    // Remove title attribute to prevent browser's default dark tooltip
                    weekDiv.removeAttribute('title');
                    
                    container.appendChild(weekDiv);
                }
                
                // Debug: log events found for this year
                if (eventCount > 0) {
                    console.log(`Year ${year}: Found ${eventCount} events`);
                }
            }
            
            // Scroll to "Today" after rendering
            setTimeout(() => {
                const todayElement = container.querySelector('.week-box.today');
                if (todayElement) {
                    const mainContent = document.getElementById('main-content');
                    const elementTop = todayElement.getBoundingClientRect().top;
                    const mainContentTop = mainContent.getBoundingClientRect().top;
                    const targetScroll = mainContent.scrollTop + elementTop - mainContentTop - (mainContent.clientHeight / 2) + (todayElement.offsetHeight / 2);
                    mainContent.scrollTo({
                        top: targetScroll,
                        behavior: 'smooth'
                    });
                }
            }, 100);
        }

        document.getElementById('reload-btn').addEventListener('click', () => {
            renderVisualization();
        });
        document.getElementById('clear-storage-btn').addEventListener('click', () => {
            if (confirm('Clear cached data and reload from YAML file?')) {
                localStorage.removeItem('lifeEvents');
                eventsData = {};
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Reloading from YAML file...';
                loadData();
            }
        });

        // Keep tooltip visible when hovering over it (add once, outside the loop)
        const tooltip = document.getElementById('tooltip');
        tooltip.addEventListener('mouseenter', () => {
            cancelHideTooltip();
        });
        tooltip.addEventListener('mouseleave', () => {
            hideTooltip();
        });

        // Initialize
        loadData();
        
        // Profile image editing functionality - Complete implementation
        const profileImage = document.getElementById('profile-image');
        const editImageBtn = document.getElementById('edit-image-btn');
        const cropModal = document.getElementById('crop-modal');
        const imageInput = document.getElementById('image-input');
        const cropPreview = document.getElementById('crop-preview');
        const cropCanvas = document.getElementById('crop-canvas');
        const uploadArea = document.getElementById('upload-area');
        
        // Modal states
        const modalEmpty = document.getElementById('modal-empty');
        const modalCropping = document.getElementById('modal-cropping');
        const modalSaving = document.getElementById('modal-saving');
        
        // Buttons
        const cancelEmptyBtn = document.getElementById('cancel-empty-btn');
        const replaceImageBtn = document.getElementById('replace-image-btn');
        const cancelCropBtn = document.getElementById('cancel-crop-btn');
        const saveCropBtn = document.getElementById('save-crop-btn');
        
        // State management
        let modalStep = 'EMPTY'; // EMPTY | CROPPING | SAVING
        let currentImage = null;
        let imageObjectUrl = null; // For cleanup (object URLs only)
        let initialImageUrl = null; // Existing image URL (not an object URL, don't revoke)
        let cropData = { x: 0, y: 0, size: 0, displayWidth: 0, displayHeight: 0 };
        let croppedAreaPixels = null;
        
        // Utility: Get cropped square blob
        function getCroppedSquareBlob(imageSrc, croppedAreaPixels) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => {
                    const canvas = document.createElement('canvas');
                    // Use actual cropped dimensions from original image for zero quality loss
                    // This preserves the original resolution without any scaling
                    const outputSize = Math.max(croppedAreaPixels.width, croppedAreaPixels.height);
                    canvas.width = outputSize;
                    canvas.height = outputSize;
                    const ctx = canvas.getContext('2d');
                    
                    // Enable high-quality image smoothing for scaling
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Draw the exact cropped area from the original image
                    ctx.drawImage(
                        image,
                        croppedAreaPixels.x,
                        croppedAreaPixels.y,
                        croppedAreaPixels.width,
                        croppedAreaPixels.height,
                        0, 0, outputSize, outputSize
                    );
                    
                    // Use PNG format (lossless) to ensure zero quality loss
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create blob'));
                        }
                    }, 'image/png');
                };
                image.onerror = reject;
                image.src = imageSrc;
            });
        }
        
        // Utility: Switch modal state
        function setModalState(state) {
            modalStep = state;
            modalEmpty.classList.toggle('active', state === 'EMPTY');
            modalCropping.classList.toggle('active', state === 'CROPPING');
            modalSaving.classList.toggle('active', state === 'SAVING');
            
            // Disable/enable buttons based on state
            if (state === 'SAVING') {
                saveCropBtn.disabled = true;
                cancelCropBtn.disabled = true;
                replaceImageBtn.disabled = true;
            } else {
                saveCropBtn.disabled = !croppedAreaPixels;
                cancelCropBtn.disabled = false;
                replaceImageBtn.disabled = false;
            }
        }
        
        // Utility: Cleanup object URLs (only revoke object URLs, not initial image URLs)
        function cleanupObjectUrl() {
            if (imageObjectUrl) {
                URL.revokeObjectURL(imageObjectUrl);
                imageObjectUrl = null;
            }
        }
        
        // Load saved image from localStorage
        // Check for new format (original + crop) or old format (just cropped)
        const savedCroppedImage = localStorage.getItem('profileImageCroppedSrc');
        const savedOriginalImage = localStorage.getItem('profileImageOriginalSrc');
        const savedCropMetadata = localStorage.getItem('profileImageCrop');
        const oldSavedImage = localStorage.getItem('profileImage'); // Backward compatibility
        
        if (savedCroppedImage && savedCroppedImage.trim() !== '') {
            // Use cropped image for display
            profileImage.src = savedCroppedImage;
            // Store original for editing (or cropped if no original exists - backward compatibility)
            initialImageUrl = savedOriginalImage || savedCroppedImage;
        } else if (oldSavedImage && oldSavedImage.trim() !== '') {
            // Backward compatibility: old format stored as 'profileImage'
            profileImage.src = oldSavedImage;
            initialImageUrl = oldSavedImage;
            // Migrate to new format
            localStorage.setItem('profileImageCroppedSrc', oldSavedImage);
            localStorage.removeItem('profileImage');
        } else {
            // No saved image, use placeholder
            profileImage.src = 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'96\' height=\'96\'%3E%3Crect width=\'96\' height=\'96\' fill=\'%23F5F5F5\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' dominant-baseline=\'middle\' text-anchor=\'middle\' font-family=\'Arial\' font-size=\'14\' fill=\'%23727272\'%3EPoro%3C/text%3E%3C/svg%3E';
            profileImage.style.display = 'block';
            initialImageUrl = null;
        }
        
        // Load existing image into crop state
        function loadExistingImageForCrop(imageUrl, cropMetadata = null) {
            currentImage = new Image();
            currentImage.onload = () => {
                cropPreview.src = imageUrl;
                cropPreview.style.display = 'block';
                setModalState('CROPPING');
                setupCrop(cropMetadata); // Pass crop metadata to restore position
            };
            currentImage.onerror = () => {
                console.error('Failed to load existing image');
                setModalState('EMPTY');
            };
            currentImage.src = imageUrl;
        }
        
        // Open crop modal
        editImageBtn.addEventListener('click', () => {
            cropModal.classList.add('show');
            imageInput.value = '';
            cleanupObjectUrl(); // Clean up any previous object URL
            croppedAreaPixels = null;
            
            // Check if there's an existing original image
            const existingOriginal = localStorage.getItem('profileImageOriginalSrc');
            const savedCrop = localStorage.getItem('profileImageCrop');
            let parsedCrop = null;
            if (savedCrop) {
                try {
                    parsedCrop = JSON.parse(savedCrop);
                } catch (e) {
                    console.error('Failed to parse crop metadata:', e);
                }
            }
            
            if (existingOriginal && existingOriginal.trim() !== '') {
                // Load original image directly into CROPPING state with saved crop position
                initialImageUrl = existingOriginal;
                loadExistingImageForCrop(existingOriginal, parsedCrop);
            } else {
                // No existing image, show upload dropzone
                initialImageUrl = null;
                currentImage = null;
                setModalState('EMPTY');
            }
            
            // Focus trap - focus first focusable element
            cropModal.setAttribute('tabindex', '-1');
            cropModal.focus();
        });
        
        // Close modal
        function closeModal() {
            cropModal.classList.remove('show');
            cleanupObjectUrl(); // Only revoke object URLs, not initial image
            // Reset transient state but keep initialImageUrl
            currentImage = null;
            croppedAreaPixels = null;
            imageInput.value = '';
            cropPreview.style.display = 'none';
            setModalState('EMPTY');
            // Don't clear initialImageUrl - it's the saved image
        }
        
        // Keyboard support (Esc to close)
        cropModal.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
        
        // Click outside to close
        cropModal.addEventListener('click', (e) => {
            if (e.target === cropModal) {
                closeModal();
            }
        });
        
        // File validation
        function validateFile(file) {
            const maxSize = 10 * 1024 * 1024; // 10MB
            const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
            
            if (!allowedTypes.includes(file.type)) {
                alert('Please upload a JPG, PNG, or WEBP image.');
                return false;
            }
            
            if (file.size > maxSize) {
                alert('Image size must be less than 10MB.');
                return false;
            }
            
            return true;
        }
        
        // Handle file upload
        function handleFileUpload(file) {
            if (!validateFile(file)) return;
            
            cleanupObjectUrl(); // Revoke previous object URL if any
            initialImageUrl = null; // Clear initial image when new file is uploaded
            
            imageObjectUrl = URL.createObjectURL(file);
            currentImage = new Image();
            
            currentImage.onload = () => {
                cropPreview.src = imageObjectUrl;
                cropPreview.style.display = 'block';
                setModalState('CROPPING');
                setupCrop(); // No saved crop for new upload
            };
            
            currentImage.onerror = () => {
                alert('Failed to load image. Please try another file.');
                cleanupObjectUrl();
            };
            
            currentImage.src = imageObjectUrl;
        }
        
        // File input change
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFileUpload(file);
            }
        });
        
        // Upload area click
        uploadArea.addEventListener('click', () => {
            imageInput.click();
        });
        
        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFileUpload(file);
            }
        });
        
        function setupCrop(savedCropMetadata = null) {
            const stage = document.getElementById('crop-stage');
            const container = document.getElementById('crop-preview-container');
            const preview = cropPreview;
            
            // Stage is always square (1:1 aspect ratio)
            const stageSize = stage.offsetWidth;
            
            // Calculate image display size to cover the square stage
            const imageAspect = currentImage.width / currentImage.height;
            let displayWidth, displayHeight;
            
            if (imageAspect > 1) {
                // Landscape - fit height to stage, width extends
                displayHeight = stageSize;
                displayWidth = displayHeight * imageAspect;
            } else {
                // Portrait or square - fit width to stage, height extends
                displayWidth = stageSize;
                displayHeight = displayWidth / imageAspect;
            }
            
            // Center the image
            preview.style.width = displayWidth + 'px';
            preview.style.height = displayHeight + 'px';
            preview.style.position = 'absolute';
            preview.style.top = '50%';
            preview.style.left = '50%';
            preview.style.transform = 'translate(-50%, -50%)';
            preview.style.display = 'block';
            
            // Store display dimensions
            cropData.displayWidth = displayWidth;
            cropData.displayHeight = displayHeight;
            
            // Initialize crop area
            if (savedCropMetadata && savedCropMetadata.x !== undefined && savedCropMetadata.y !== undefined && savedCropMetadata.size !== undefined) {
                // Restore saved crop position
                cropData.x = savedCropMetadata.x;
                cropData.y = savedCropMetadata.y;
                cropData.size = savedCropMetadata.size;
                
                // Validate crop bounds
                const maxSize = Math.min(stageSize, displayWidth, displayHeight);
                cropData.size = Math.max(50, Math.min(cropData.size, maxSize));
                cropData.x = Math.max(0, Math.min(cropData.x, stageSize - cropData.size));
                cropData.y = Math.max(0, Math.min(cropData.y, stageSize - cropData.size));
            } else {
                // Default: center, square, 80% of stage
                const cropSize = stageSize * 0.8;
                cropData.x = (stageSize - cropSize) / 2;
                cropData.y = (stageSize - cropSize) / 2;
                cropData.size = cropSize;
            }
            
            // Calculate cropped area in pixels
            updateCroppedAreaPixels();
            
            // Add crop overlay
            updateCropOverlay();
        }
        
        function updateCroppedAreaPixels() {
            const scaleX = currentImage.width / cropData.displayWidth;
            const scaleY = currentImage.height / cropData.displayHeight;
            
            // Calculate crop position relative to image (not stage)
            const stageSize = document.getElementById('crop-stage').offsetWidth;
            const imageLeft = (stageSize - cropData.displayWidth) / 2;
            const imageTop = (stageSize - cropData.displayHeight) / 2;
            
            const relativeX = cropData.x - imageLeft;
            const relativeY = cropData.y - imageTop;
            
            croppedAreaPixels = {
                x: Math.max(0, relativeX * scaleX),
                y: Math.max(0, relativeY * scaleY),
                width: cropData.size * scaleX,
                height: cropData.size * scaleY
            };
            
            // Update save button state
            saveCropBtn.disabled = !croppedAreaPixels;
        }
        
        function updateCropOverlay() {
            // Remove existing overlay if any
            const existingOverlay = document.getElementById('crop-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            const stage = document.getElementById('crop-stage');
            const stageSize = stage.offsetWidth;
            
            const overlay = document.createElement('div');
            overlay.id = 'crop-overlay';
            overlay.className = 'crop-overlay';
            overlay.style.pointerEvents = 'none';
            
            // Create 4 dark overlay divs around the crop box
            const top = document.createElement('div');
            top.className = 'crop-overlay-top';
            top.style.height = cropData.y + 'px';
            
            const bottom = document.createElement('div');
            bottom.className = 'crop-overlay-bottom';
            bottom.style.height = (stageSize - cropData.y - cropData.size) + 'px';
            bottom.style.top = (cropData.y + cropData.size) + 'px';
            
            const left = document.createElement('div');
            left.className = 'crop-overlay-left';
            left.style.width = cropData.x + 'px';
            left.style.top = cropData.y + 'px';
            left.style.height = cropData.size + 'px';
            
            const right = document.createElement('div');
            right.className = 'crop-overlay-right';
            right.style.width = (stageSize - cropData.x - cropData.size) + 'px';
            right.style.left = (cropData.x + cropData.size) + 'px';
            right.style.top = cropData.y + 'px';
            right.style.height = cropData.size + 'px';
            
            overlay.appendChild(top);
            overlay.appendChild(bottom);
            overlay.appendChild(left);
            overlay.appendChild(right);
            
            // Create crop box with handles
            const cropBox = document.createElement('div');
            cropBox.className = 'crop-box';
            cropBox.style.left = cropData.x + 'px';
            cropBox.style.top = cropData.y + 'px';
            cropBox.style.width = cropData.size + 'px';
            cropBox.style.height = cropData.size + 'px';
            
            // Add resize handles
            const handles = ['nw', 'ne', 'sw', 'se'];
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `crop-handle ${handle}`;
                cropBox.appendChild(handleEl);
            });
            
            overlay.appendChild(cropBox);
            
            const container = document.getElementById('crop-preview-container');
            container.appendChild(overlay);
            
            // Make crop box draggable and resizable
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let startX = 0;
            let startY = 0;
            let startCropX = 0;
            let startCropY = 0;
            let startCropSize = 0;
            
            // Handle dragging
            cropBox.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('crop-handle')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startCropX = cropData.x;
                startCropY = cropData.y;
                e.preventDefault();
                e.stopPropagation();
            });
            
            // Handle resizing via handles
            const handleElements = cropBox.querySelectorAll('.crop-handle');
            handleElements.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    resizeHandle = handle.classList[1]; // nw, ne, sw, or se
                    startX = e.clientX;
                    startY = e.clientY;
                    startCropX = cropData.x;
                    startCropY = cropData.y;
                    startCropSize = cropData.size;
                    e.preventDefault();
                    e.stopPropagation();
                });
            });
            
            // Global mouse move handler
            const mouseMoveHandler = (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    const newX = Math.max(0, Math.min(startCropX + deltaX, stageSize - cropData.size));
                    const newY = Math.max(0, Math.min(startCropY + deltaY, stageSize - cropData.size));
                    
                    cropData.x = newX;
                    cropData.y = newY;
                    
                    updateCropOverlay();
                    updateCroppedAreaPixels();
                } else if (isResizing) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    const delta = Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY;
                    
                    let newSize = startCropSize;
                    let newX = startCropX;
                    let newY = startCropY;
                    
                    // Calculate new size based on handle
                    if (resizeHandle === 'se' || resizeHandle === 'ne') {
                        newSize = Math.max(50, Math.min(startCropSize + delta, stageSize - Math.max(startCropX, startCropY)));
                    } else {
                        newSize = Math.max(50, Math.min(startCropSize - delta, Math.min(startCropX + startCropSize, startCropY + startCropSize)));
                    }
                    
                    // Maintain 1:1 aspect ratio and constrain to stage
                    newSize = Math.max(50, Math.min(newSize, stageSize));
                    
                    // Adjust position based on handle
                    if (resizeHandle === 'nw') {
                        newX = startCropX + startCropSize - newSize;
                        newY = startCropY + startCropSize - newSize;
                    } else if (resizeHandle === 'ne') {
                        newX = startCropX;
                        newY = startCropY + startCropSize - newSize;
                    } else if (resizeHandle === 'sw') {
                        newX = startCropX + startCropSize - newSize;
                        newY = startCropY;
                    } else { // se
                        newX = startCropX;
                        newY = startCropY;
                    }
                    
                    // Constrain to stage bounds
                    newX = Math.max(0, Math.min(newX, stageSize - newSize));
                    newY = Math.max(0, Math.min(newY, stageSize - newSize));
                    
                    cropData.x = newX;
                    cropData.y = newY;
                    cropData.size = newSize;
                    
                    updateCropOverlay();
                    updateCroppedAreaPixels();
                }
            };
            
            const mouseUpHandler = () => {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            };
            
            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
            
            // Store handlers for cleanup
            overlay._mouseMoveHandler = mouseMoveHandler;
            overlay._mouseUpHandler = mouseUpHandler;
        }
        
        // Save cropped image
        saveCropBtn.addEventListener('click', async () => {
            if (!currentImage || !croppedAreaPixels) return;
            
            setModalState('SAVING');
            
            try {
                // Use the appropriate image source (object URL for new uploads, initial URL for existing)
                const imageSrc = imageObjectUrl || initialImageUrl;
                if (!imageSrc) {
                    throw new Error('No image source available');
                }
                
                const blob = await getCroppedSquareBlob(imageSrc, croppedAreaPixels);
                const previewUrl = URL.createObjectURL(blob);
                
                // Update profile image (display uses cropped version)
                profileImage.src = previewUrl;
                
                // Save cropped output for display
                const reader = new FileReader();
                reader.onload = () => {
                    const croppedDataUrl = reader.result;
                    localStorage.setItem('profileImageCroppedSrc', croppedDataUrl);
                    
                    // Save original image (if it's a new upload, convert to data URL)
                    if (imageObjectUrl) {
                        // New upload - save the original file as data URL
                        const originalReader = new FileReader();
                        originalReader.onload = () => {
                            localStorage.setItem('profileImageOriginalSrc', originalReader.result);
                            
                            // Save crop metadata (position and size relative to stage)
                            const cropMetadata = {
                                x: cropData.x,
                                y: cropData.y,
                                size: cropData.size
                            };
                            localStorage.setItem('profileImageCrop', JSON.stringify(cropMetadata));
                            
                            // Update initialImageUrl to the saved original
                            initialImageUrl = originalReader.result;
                            
                            closeModal();
                        };
                        // Get the file from the input
                        const fileInput = document.getElementById('image-input');
                        if (fileInput.files && fileInput.files[0]) {
                            originalReader.readAsDataURL(fileInput.files[0]);
                        } else {
                            // Fallback: if we can't get the file, use the object URL
                            fetch(imageObjectUrl)
                                .then(res => res.blob())
                                .then(blob => {
                                    const fr = new FileReader();
                                    fr.onload = () => {
                                        localStorage.setItem('profileImageOriginalSrc', fr.result);
                                        const cropMetadata = {
                                            x: cropData.x,
                                            y: cropData.y,
                                            size: cropData.size
                                        };
                                        localStorage.setItem('profileImageCrop', JSON.stringify(cropMetadata));
                                        initialImageUrl = fr.result;
                                        closeModal();
                                    };
                                    fr.readAsDataURL(blob);
                                });
                        }
                    } else {
                        // Existing image - original is already saved, just update crop metadata
                        const cropMetadata = {
                            x: cropData.x,
                            y: cropData.y,
                            size: cropData.size
                        };
                        localStorage.setItem('profileImageCrop', JSON.stringify(cropMetadata));
                        closeModal();
                    }
                };
                reader.readAsDataURL(blob);
            } catch (error) {
                console.error('Error saving cropped image:', error);
                alert('Failed to save image. Please try again.');
                setModalState('CROPPING');
            }
        });
        
        // Replace image (back to EMPTY)
        replaceImageBtn.addEventListener('click', () => {
            cleanupObjectUrl(); // Revoke object URL if it was a new upload
            currentImage = null;
            croppedAreaPixels = null;
            initialImageUrl = null; // Clear initial image so upload UI shows
            imageInput.value = '';
            cropPreview.style.display = 'none';
            setModalState('EMPTY');
        });
        
        // Cancel buttons
        cancelEmptyBtn.addEventListener('click', closeModal);
        cancelCropBtn.addEventListener('click', closeModal);
        
        // Resizer functionality
        const resizer = document.getElementById('resizer');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('main-content');
        
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;
        
        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startWidth = parseInt(document.defaultView.getComputedStyle(sidebar).width, 10);
            resizer.classList.add('dragging');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const width = startWidth + e.clientX - startX;
            const minWidth = 250;
            const maxWidth = 600;
            
            if (width >= minWidth && width <= maxWidth) {
                sidebar.style.width = width + 'px';
                resizer.style.left = width + 'px';
                mainContent.style.marginLeft = width + 'px';
                mainContent.style.width = `calc(100% - ${width}px)`;
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });
    </script>
</body>
</html>
